class alu_agent extends uvm_agent;
	alu_driver    alu_driv;
	alu_sequencer alu_seqr;
	alu_monitor   alu_mon;

	`uvm_component_utils(alu_agent)

	function new (string name = "alu_agent", uvm_component parent);
		super.new(name, parent);
	endfunction 

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		if(get_is_active() == UVM_ACTIVE) begin
			alu_driv = alu_driver::type_id::create("alu_driv", this);
			alu_seqr = alu_sequencer::type_id::create("alu_seqr", this);
		end
		alu_mon = alu_monitor::type_id::create("alu_mon", this);
	endfunction

	function void connect_phase(uvm_phase phase);
		if(get_is_active() == UVM_ACTIVE) begin
			alu_driv.seq_item_port.connect(alu_seqr.seq_item_export);
		end
	endfunction

endclass  


typedef enum{ADD,SUB,ADD_CIN,SUB_CIN,INC_A,DEC_A,INC_B,DEC_B,CMP,ADD_MUL,SH_MUL}arith;
typedef enum{AND,NAND,OR,NOR,XOR,XNOR,NOT_A,NOT_B,SHR1_A,SHL1_A,SHR1_B,SHL1_B,ROL_A_B,ROR_A_B}logical;
interface alu_assertions(clk,rst,ce,opa,opb,mode,inp_valid,cmd,cin,res,err,cout,oflow,g,l,e);
	input clk;
	input rst;
	input ce;
	input [`DATA_WIDTH - 1 : 0] opa;
	input [`DATA_WIDTH - 1 : 0]opb;
	input mode;
	input [1:0] inp_valid;
	input [`CMD_WIDTH - 1 : 0]cmd;
	input cin;
	input [RESULT_WIDTH - 1 : 0]res;
	input err,cout,oflow,g,l,e;

	property ALU_Known;
		@(posedge clk)
		##1 !($isunknown({rst,ce,opa,opb,mode,inp_valid,cmd,cin}));
	endproperty

	ALU_KNOWN: assert property(ALU_Known)
	$info("INPUTS SIGNALS ARE KNOWN: %d %d %d %d %d %d %d %d",rst,ce,opa,opb,mode,inp_valid,cmd,cin);
	else $info("INPUTS SIGNALS ARE UNKNOWN");

	ALU_RESET: assert property(@(posedge clk) ##10 !rst )
	$info("RESET IS NOT TRIGGERED");
	else $info("RESET IS TRIGGERED");

	property ALU_Clock_Enable;
		@(posedge clk)
			##10 ce |-> res != ($past(res));
	endproperty

	ALU_CLOCK_ENABLE: assert property(ALU_Clock_Enable)
  $info("OUTPUTS ARE NOT LATCHED :%d %d %d %d %d %d %d",res,oflow,cout,g,l,e,err);
	else $info("OUTPUTS ARE LATCHED");

	/*
	property cycle16_interruption;
		@(posedge clk)
			( inp_valid == 1 || inp_valid == 2 ) |=> ##[1:15] res ;
	endproperty

	ALU_CLOCK_ENABLE: assert property(cycle16_interruption)
  $info("16_clock_cycle is interrupted");
	else $info("16_clock_cycle is not interrupted");
*/



endinterface
`uvm_analysis_imp_decl(_mon_cg)
`uvm_analysis_imp_decl(_driv_cg)

class alu_coverage extends uvm_component;
	`uvm_component_utils(alu_coverage)
	virtual alu_interface vif;
	uvm_analysis_imp_mon_cg #(alu_sequence_item, alu_coverage) cov_mon_port;
	uvm_analysis_imp_driv_cg #(alu_sequence_item, alu_coverage) cov_driv_port;
	alu_sequence_item mon, driv;
	real mon_cov_results, driv_cov_results;

	covergroup driver_coverage;
		option.per_instance = 1;
		//opa         : coverpoint driv.opa       { bins opa[] = {[0:255]} with (item / 32 ); }
		//opb         : coverpoint driv.opb       { bins opb[] = {[0:255]} with (item / 32 ); }
		cmd         : coverpoint driv.cmd      { 
		                                         	bins arithmatic_cmd[] = {[0:10]} iff (driv.mode == 1'b1);
                                        			bins logical_cmd[]    = {[0:13]} iff (driv.mode == 1'b0);
		                                        }
		inp_valid   : coverpoint driv.inp_valid { bins inp_valid[]  = {0,1,2,3}; }
		cin         : coverpoint driv.cin       { bins cin[]        = {0,1}; }
		mode        : coverpoint driv.mode      { bins mode[]       = {0,1}; } 
		ce          : coverpoint driv.ce        { bins ce[]         = {0,1}; }
		rst         : coverpoint driv.rst       { bins rst[]        = {0,1}; }
		rstXce        : cross rst , ce ; 
		ceXmode       : cross ce , mode;
		inp_validXmode: cross inp_valid , mode;
		modeXcmd      : cross mode , cmd {
			bins add              = binsof(cmd) intersect{0}  && binsof(mode) intersect{1};
			bins sub              = binsof(cmd) intersect{1}  && binsof(mode) intersect{1};
			bins add_cin          = binsof(cmd) intersect{2}  && binsof(mode) intersect{1};
			bins sub_cin          = binsof(cmd) intersect{3}  && binsof(mode) intersect{1};
			bins inc_A            = binsof(cmd) intersect{4}  && binsof(mode) intersect{1};
			bins dec_A            = binsof(cmd) intersect{5}  && binsof(mode) intersect{1};
			bins inc_B            = binsof(cmd) intersect{6}  && binsof(mode) intersect{1};
			bins dec_B            = binsof(cmd) intersect{7}  && binsof(mode) intersect{1};
			bins compare          = binsof(cmd) intersect{8}  && binsof(mode) intersect{1};
			bins inc_mul          = binsof(cmd) intersect{9}  && binsof(mode) intersect{1};
			bins shift_mul        = binsof(cmd) intersect{10} && binsof(mode) intersect{1};
			bins and_op           = binsof(cmd) intersect{0}  && binsof(mode) intersect{0};
			bins nand_op          = binsof(cmd) intersect{1}  && binsof(mode) intersect{0};
			bins or_op            = binsof(cmd) intersect{2}  && binsof(mode) intersect{0};
			bins nor_op           = binsof(cmd) intersect{3}  && binsof(mode) intersect{0};
			bins xor_op           = binsof(cmd) intersect{4}  && binsof(mode) intersect{0};
			bins xnor_op          = binsof(cmd) intersect{5}  && binsof(mode) intersect{0};
			bins notA_op          = binsof(cmd) intersect{6}  && binsof(mode) intersect{0};
			bins notB_op          = binsof(cmd) intersect{7}  && binsof(mode) intersect{0};
			bins shift_right_A_op = binsof(cmd) intersect{8}  && binsof(mode) intersect{0};
			bins shift_left_A_op  = binsof(cmd) intersect{9}  && binsof(mode) intersect{0};
			bins shift_right_B_op = binsof(cmd) intersect{10} && binsof(mode) intersect{0};
			bins shift_left_B_op  = binsof(cmd) intersect{11} && binsof(mode) intersect{0};
			bins rotate_left_op   = binsof(cmd) intersect{12} && binsof(mode) intersect{0};
			bins rotate_right_op  = binsof(cmd) intersect{13} && binsof(mode) intersect{0}; 
		}
	endgroup

	covergroup monitor_coverage;
		option.per_instance = 1;
		//	result : coverpoint mon.res  { bins res_bins[]   = {[0:65535]} with (item / 64); }
		oflow  : coverpoint mon.oflow{ bins oflow[]      = {0,1}; }
		cout   : coverpoint mon.cout { bins cout[]       = {0,1}; }
		err    : coverpoint mon.err  { bins err[]        = {0,1}; }
		g      : coverpoint mon.g    { bins g[]          = {0,1}; } 
		l      : coverpoint mon.l    { bins l[]          = {0,1}; }
		e      : coverpoint mon.e    { bins e[]          = {0,1}; } 
	endgroup

	function new(string name = "alu_coverage", uvm_component parent);
		super.new(name, parent);
		monitor_coverage = new();
		driver_coverage  = new();
		cov_driv_port    = new("cov_driv_port", this);
		cov_mon_port     = new("cov_mon_port", this);
	endfunction

	function void write_driv_cg(alu_sequence_item driv_seq);
		driv = driv_seq;
		driver_coverage.sample();
	endfunction

	function void write_mon_cg(alu_sequence_item mon_seq);
		mon = mon_seq;
		monitor_coverage.sample();
	endfunction

	function void extract_phase(uvm_phase phase);
		super.extract_phase(phase);
		driv_cov_results = driver_coverage.get_coverage();
		mon_cov_results  = monitor_coverage.get_coverage();
	endfunction

	function void report_phase(uvm_phase phase);
		super.report_phase(phase);
		`uvm_info(get_type_name, $sformatf("[DRIVER] Coverage ------> %0.2f%%,", driv_cov_results), UVM_MEDIUM);
		`uvm_info(get_type_name, $sformatf("[MONITOR] Coverage ------> %0.2f%%", mon_cov_results), UVM_MEDIUM);
	endfunction
endclass
module alu_design#(parameter OPERAND_WIDTH = 8, parameter CMD_WIDTH = 4)(
	// INPUTS
	input CLK, RST, MODE, CE, CIN,
	input [CMD_WIDTH-1:0] CMD,
	input [1:0] INP_VALID,
	input [OPERAND_WIDTH-1:0] OPA, OPB,
	// OUTPUTS
	output reg ERR, OFLOW, E, G, L,
	output COUT,
	output reg [(2*OPERAND_WIDTH)-1:0] RES
);

	// Registers for Pipeling
	reg [3:0] t_CMD;
	reg [OPERAND_WIDTH-1:0] t_OPA, t_OPB;
	reg t_CIN, temp_ovr_cin;
	reg t_MODE;
	reg TEMP_MODE;
	reg [3:0]TEMP_CMD;
	reg [1:0] t_INP_VALID;
	reg [OPERAND_WIDTH-1:0] shf_MUL;
	reg [(2*OPERAND_WIDTH)-1:0] t_MUL;
	reg [OPERAND_WIDTH-1:0] temp_ovr_a, temp_ovr_b;

	// Always Block for Initializing and Pipeling the Inputs
	always @ (posedge CLK or posedge RST) begin
		if(RST) begin
			t_OPA <= 0;
			t_OPB <= 0;
			t_CMD <= 0;
			temp_ovr_a <= 0;
			temp_ovr_b <= 0;
			TEMP_MODE <= 0;
			TEMP_CMD <= 0;
			temp_ovr_cin <= 0;
			t_MODE <= 0;
			t_INP_VALID <=0;
			t_CIN <= 0;
		end
		else if(CE) begin
			t_OPA <= OPA;
			t_OPB <= OPB;
			temp_ovr_a <= t_OPA;
			temp_ovr_b <= t_OPB;
			TEMP_MODE <= t_MODE;
			TEMP_CMD <= t_CMD;
			temp_ovr_cin <= t_CIN;
			t_CMD <= CMD;
			t_MODE <= MODE;
			t_INP_VALID <= INP_VALID;
			t_CIN <= CIN;       
		end
		else begin
			t_OPA <= 0;
			t_OPB <= 0;
			t_CMD <= 0;
			temp_ovr_a <= 0;
			temp_ovr_b <= 0;
			t_MODE <= 0;
			t_INP_VALID <= 0;
			t_CIN <= 0;
		end  
	end

	// Always block for ALU Computations
	always @ (posedge CLK or posedge RST) begin
		if(RST) begin           // Reset will result is ZERO
			RES <= 0;
			ERR <= 1'b0;
			t_MUL <= 0;
			E <= 1'b0;
			G <= 1'b0;
			L <= 1'b0;
		end
		else begin
			if(CE) begin
				if(t_MODE) begin                // MODE = 1 (ARITHMETIC)
					if(t_CMD != 4'd9 && t_CMD != 4'd10)     // If Command is not multiplication make res = 0
						RES <= 0;
					ERR <= 1'b0;
					E <= 1'b0;
					G <= 1'b0;
					L <= 1'b0;
					t_MUL <= 0;
					case(t_INP_VALID)
						2'b00 : begin                   // Both Operands are Invalid
							RES <= 0;
							ERR <= 1'b1;
							E <= 1'b0;
							G <= 1'b0;
							L <= 1'b0;
						end
						2'b01 : begin                   // Only OPA is VALID
							case(t_CMD)     
								4'b0100 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA + 1;      // Increment OPA    
								end
								4'b0101 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA - 1;      // Decrement OPB
								end
								default : begin                                     // Invalid CMD for Single Input (OPA)
									RES <= 0;
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
						2'b10 : begin                   // Only OPB is VALID
							case(t_CMD)
								4'b0110 : begin
									RES[OPERAND_WIDTH:0] <= t_OPB + 1;      // Increment OPB
								end
								4'b0111 : begin
									RES[OPERAND_WIDTH:0] <= t_OPB - 1;      // Decrement OPB
								end
								default : begin                                     // Invalid CMD for Single Input (OPB)
									RES <= 0;   
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
						default : begin                                                     // When Both Operands are VALID
							case(t_CMD)
								4'b0000 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA + t_OPB;          // ADDITION
								end
								4'b0001 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA - t_OPB;          // SUBTRACTION
								end
								4'b0010 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA + t_OPB + t_CIN;  // ADDITION WITH CARRY
								end
								4'b0011 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA - t_OPB - t_CIN;  // SUBTRACTION WITH BORROW
								end
								4'b0100 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA + 1;              // INCREMENT OPA 
								end
								4'b0101 : begin
									RES[OPERAND_WIDTH:0] <= t_OPA - 1;              // DECREMENT OPA
								end
								4'b0110 : begin
									RES[OPERAND_WIDTH:0] <= t_OPB + 1;              // INCREMENT OPB 
								end
								4'b0111 : begin
									RES[OPERAND_WIDTH:0] <= t_OPB - 1;              // DECREMENT OPB
								end
								4'b1000 : begin                                             // UNSIGNED COMPARISON
									RES <= 0;
									if(t_OPA == t_OPB) begin
										E <= 1;
										G <= 0;
										L <= 0;
									end
									else if(t_OPA > t_OPB) begin
										E <= 0;
										G <= 1;
										L <= 0;
									end
									else begin
										E <= 0;
										G <= 0;
										L <= 1;
									end
								end
								4'b1001 : begin
									t_MUL <= (t_OPA + 1) * (t_OPB + 1);             // MULTIPLICATION (OPA+1) x (OPB+1)
									RES <= t_MUL;
								end
								4'b1010 : begin
									t_MUL <= (shf_MUL) * (t_OPB);                   // MULTIPLICATION (OPA << 1) x (OPB)
									RES <= t_MUL;
								end
								4'b1011 : begin                                             // Signed ADDITION and COMPARISON
									RES[OPERAND_WIDTH:0] <= ($signed(t_OPA)) + ($signed(t_OPB));
									if(t_OPA == t_OPB) begin
										E <= 1;
										G <= 0;
										L <= 0;
									end
									else if(($signed(t_OPA)) > ($signed(t_OPB))) begin
										E <= 0;
										G <= 1;
										L <= 0;
									end
									else begin
										E <= 0;
										G <= 0;
										L <= 1;
									end
								end
								4'b1100 : begin                                             // Signed SUBTRACTION and COMPARISON                  
									RES[OPERAND_WIDTH:0] <= ($signed(t_OPA)) - ($signed(t_OPB));
									if(t_OPA == t_OPB) begin
										E <= 1;
										G <= 0;
										L <= 0;
									end
									else if(($signed(t_OPA)) > ($signed(t_OPB))) begin
										E <= 0;
										G <= 1;
										L <= 0;
									end
									else begin
										E <= 0;
										G <= 0;
										L <= 1;
									end
								end
								default :  begin                                            // Invalid CMD for Both Inputs
									RES <= 0;
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
					endcase
				end
				else begin                  // MODE = 0 (LOGICAL OPERATION)
					RES <= 0;
					ERR <= 1'b0;
					E <= 1'b0;
					G <= 1'b0;
					L <= 1'b0;
					case(t_INP_VALID)           
						2'b00 : begin                   // Both Inputs are INVALID
							RES <= 0;
							ERR <= 1'b1;
							E <= 1'b0;
							G <= 1'b0;
							L <= 1'b0;
						end
						2'b01 : begin                   // Only OPA is VALID
							case(t_CMD)
								4'b0110 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPA)};         // NOT ~OPA
								4'b1000 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA >> 1)};     // Right Shift OPA
								4'b1001 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA << 1)};     // Left Shift OPA
								default : begin                                             // Invalid CMD for Single Input (OPA)
									RES <= 0;
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
						2'b10 : begin                   // Only OPA is VALID
							case(t_CMD)
								4'b0111 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPB)};         // NOT ~OPA
								4'b1010 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPB >> 1)};     // Right Shift OPB
								4'b1011 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPB << 1)};     // Left Shift OPA
								default : begin                                             // Invalid CMD for Single Input (OPB)
									RES <= 0;
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
						default : begin
							case(t_CMD)
								4'b0000 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA & t_OPB)};  // Bitwise AND
								4'b0001 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPA & t_OPB)}; // Bitwise NAND
								4'b0010 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA | t_OPB)};  // Bitwise OR
								4'b0011 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPA | t_OPB)}; // Bitwise NOR
								4'b0100 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA ^ t_OPB)};  // Bitwise XOR
								4'b0101 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPA ^ t_OPB)}; // Bitwise XNOR
								4'b0110 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPA)};         // Bitwise NOT - OPA
								4'b0111 : RES[OPERAND_WIDTH:0] <= {1'b0, ~(t_OPB)};         // Bitwise NOT - OPB
								4'b1000 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA >> 1)};     // Shift Right OPA
								4'b1001 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPA << 1)};     // Shift Left OPA
								4'b1010 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPB >> 1)};     // Shift Right OPB
								4'b1011 : RES[OPERAND_WIDTH:0] <= {1'b0, (t_OPB << 1)};     // Shift Left OPB
								4'b1100 :   begin                                           // Rotate LEFT
									RES[OPERAND_WIDTH-1:0] <= (t_OPA << t_OPB[($clog2(OPERAND_WIDTH) - 1):0]) | (t_OPA >> (OPERAND_WIDTH - t_OPB[($clog2(OPERAND_WIDTH) - 1):0]));
									if(|(t_OPB[OPERAND_WIDTH-1 : ($clog2(OPERAND_WIDTH) + 1)]))
										ERR <= 1;
									else
										ERR <= 0;
								end
								4'b1101 :   begin                                           // Rotate RIGHT
									RES[OPERAND_WIDTH-1:0] <= (t_OPA >> t_OPB[($clog2(OPERAND_WIDTH) - 1):0]) | (t_OPA << (OPERAND_WIDTH - t_OPB[($clog2(OPERAND_WIDTH) - 1):0]));
									if(|(t_OPB[OPERAND_WIDTH-1 : ($clog2(OPERAND_WIDTH) + 1)]))
										ERR <= 1;
									else
										ERR <= 0;
								end


								default :  begin                                            // Invalid CMD for Both Inputs
									RES <= 0;
									ERR <= 1'b1;
									E <= 1'b0;
									G <= 1'b0;
									L <= 1'b0;
								end
							endcase
						end
					endcase
				end
			end
			else begin   // When CE = 0
				RES <= RES;
				ERR <= 1'b0;
				E <= 1'b0;
				G <= 1'b0;
				L <= 1'b0;
			end
		end   
	end

	// For Multiplication CMD = 4'b1010
	always @ (*) begin  
		if(t_CMD == 4'hA)
			shf_MUL = t_OPA << 1;
		else
			shf_MUL = 0;
	end

	// Overflow Calculation
	always @ (*) begin
		if(TEMP_MODE) begin
			case(TEMP_CMD)
				4'd1 : OFLOW = (temp_ovr_a < temp_ovr_b);
				4'd3 : OFLOW = ((temp_ovr_a < temp_ovr_b) || (temp_ovr_a == temp_ovr_b && temp_ovr_cin == 1));
				4'd5 : OFLOW = (temp_ovr_a < 1);
				4'd7 : OFLOW = (temp_ovr_b < 1);
				4'd11 : OFLOW = (temp_ovr_a[OPERAND_WIDTH-1] & temp_ovr_b[OPERAND_WIDTH-1] & (~RES[OPERAND_WIDTH-1])) | ((~temp_ovr_a[OPERAND_WIDTH-1]) & (~temp_ovr_b[OPERAND_WIDTH-1]) & RES[OPERAND_WIDTH-1]);
				4'd12 : OFLOW = ((~temp_ovr_a[OPERAND_WIDTH-1]) & temp_ovr_b[OPERAND_WIDTH-1] & RES[OPERAND_WIDTH-1]) | (temp_ovr_a[OPERAND_WIDTH-1] & (~temp_ovr_b[OPERAND_WIDTH-1]) & (~RES[OPERAND_WIDTH-1]));
				default : OFLOW = 0;
			endcase
		end
		else
			OFLOW = 0;
	end

	// Carry Out Calculation
	assign COUT = ((TEMP_MODE) && (TEMP_CMD == 4'd0 || TEMP_CMD == 4'd2 || TEMP_CMD == 4'd4 || TEMP_CMD == 4'd6 || TEMP_CMD == 4'd11)) ? RES[8] : 0;


endmodule
class alu_driver extends uvm_driver #(alu_sequence_item);

  virtual alu_interface vif;

  `uvm_component_utils(alu_driver)
  
  uvm_analysis_port#(alu_sequence_item) driv_port; 
  function new (string name = "alu_driver", uvm_component parent);
    super.new(name, parent);
    driv_port = new("driv_port", this);
  endfunction : new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
       if(!uvm_config_db#(virtual alu_interface)::get(this,"","vif", vif))
      `uvm_fatal("NO_VIF",{"virtual interface must be set for: ALU_DRIVER ",get_full_name(),".vif"});
  endfunction

  task run_phase(uvm_phase phase);
    forever begin  
      seq_item_port.get_next_item(req);
      if( req.inp_valid == 1 || req.inp_valid == 2 )
        begin
          if( req.mode == 1 && req.cmd inside{4,5,6,7} )
              drive_signals();
          else if( req.mode == 0 && req.cmd inside{6,7,8,9,10,11} )
              drive_signals();
          else 
           begin
             for( int i = 0; i < 16; i++ ) 
             begin
              req.rst.rand_mode(0);
              req.ce.rand_mode(0);       
              req.mode.rand_mode(0);
              req.cmd.rand_mode(0);
              void'(req.randomize());
              $display(" count = %d ", i + 1); 
              if( i == 15 )
                begin
                   req.mode.rand_mode(1);
                   req.cmd.rand_mode(1);
                   drive_signals();
                end
              else 
                begin
                  if( req.inp_valid == 3 )
                     begin
                       i = 0 ;
                       drive_signals();
                       break;
                     end
                  else
                    begin
                      drive_signals(); 
                       if( ( req.mode == 1 ) && ( req.cmd == 9 || req.cmd == 10 ) )
                          repeat(4) @(vif.alu_driver_cb);  
                       else
                          repeat(3)@(vif.alu_driver_cb);
                       driv_port.write(req);
                    end
                end
             end
           end
           if( ( req.mode == 1 ) && ( req.cmd == 9 || req.cmd == 10 ) )
         	  repeat(4) @(vif.alu_driver_cb);  
       	   else
         	  repeat(3) @(vif.alu_driver_cb);     
        end
      else
        begin
          if( req.inp_valid == 0 || req.inp_valid == 3 )
             drive_signals();
             if( ( req.mode == 1 ) && ( req.cmd == 9 || req.cmd == 10 ) )
         	  repeat(4) @(vif.alu_driver_cb);  
       	     else
         	  repeat(3) @(vif.alu_driver_cb); 
        end
      $display("SENDING RESPONSE ");
      driv_port.write(req);
      seq_item_port.item_done();
      end
  endtask
  task drive_signals();
        vif.alu_driver_cb.rst       <= req.rst;
        vif.alu_driver_cb.ce        <= req.ce;
        vif.alu_driver_cb.mode      <= req.mode;
        vif.alu_driver_cb.cin       <= req.cin;
        vif.alu_driver_cb.cmd       <= req.cmd;
        vif.alu_driver_cb.inp_valid <= req.inp_valid;
        vif.alu_driver_cb.opa       <= req.opa;
        vif.alu_driver_cb.opb       <= req.opb;
        $display("Driver @ %0t \n RST = %b | CE = %b | MODE = %b | CMD = %d | INP_VALID = %d | CIN = %b | OPA = %d | OPB = %d ",
        $time, req.rst , req.ce , req.mode , req.cmd , req.inp_valid , req.cin , req.opa , req.opb );
  endtask
endclass
class alu_environment extends uvm_env;
	alu_agent      alu_agt;
	alu_scoreboard alu_scb;
	alu_coverage   alu_cov;

	`uvm_component_utils(alu_environment)

	function new(string name = "alu_environment", uvm_component parent);
		super.new(name, parent);
	endfunction

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		alu_agt = alu_agent::type_id::create("alu_agent", this);
		alu_scb = alu_scoreboard::type_id::create("alu_scoreboard", this);
		alu_cov = alu_coverage::type_id::create("alu_coverage", this);
	endfunction

	function void connect_phase(uvm_phase phase);
		alu_agt.alu_mon.mon_port.connect(alu_scb.mon_scb_port);
		alu_agt.alu_driv.driv_port.connect(alu_scb.driv_scb_port);
		alu_agt.alu_mon.mon_port.connect(alu_cov.cov_mon_port);
		alu_agt.alu_driv.driv_port.connect(alu_cov.cov_driv_port);
	endfunction

endclass


interface alu_interface(input bit clk);
	logic ce, mode , cin , rst;
	logic [`DATA_WIDTH - 1 :0] opa , opb; 
	logic [`CMD_WIDTH - 1 :0] cmd;
	logic [1:0] inp_valid;
	logic [RESULT_WIDTH - 1 :0] res ;
	logic  err , oflow , cout , g , l , e;

	clocking alu_driver_cb @(posedge clk);
		default input #1 output #1;
		output rst;
		output ce , mode ,cin;
		output cmd;
		output inp_valid;
		output opa , opb;  
	endclocking

	clocking alu_monitor_cb @(posedge clk);
		default input #1 output #1;
		input ce , mode ,cin ,rst;
		input cmd;
		input inp_valid;
		input opa , opb;  
		input res ;
		input err , oflow , cout , g , l , e;
	endclocking

	modport DRIVER(clocking alu_driver_cb);
  modport MONITOR(clocking alu_monitor_cb);

endinterface
class alu_monitor extends uvm_monitor;

	virtual alu_interface vif;

	uvm_analysis_port #(alu_sequence_item) mon_port;

	alu_sequence_item seq;

	`uvm_component_utils(alu_monitor)

	function new (string name = "alu_monitor", uvm_component parent);
		super.new(name, parent);
		mon_port = new("mon_port", this);
	endfunction

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq = alu_sequence_item::type_id::create("alu_seq");
		if(!uvm_config_db#(virtual alu_interface)::get(this, "", "vif", vif))
			`uvm_fatal("NOVIF",{"virtual interface must be set for:MONITOR INTERFACE ",get_full_name(),".vif"});
	endfunction

	task run_phase(uvm_phase phase);
		forever begin
			repeat(3) @(vif.alu_monitor_cb);

			if( (vif.alu_monitor_cb.cmd == 9 || vif.alu_monitor_cb.cmd == 10) && (vif.alu_monitor_cb.mode == 1) )
			begin
				repeat(1)@(vif.alu_monitor_cb);
			end

			seq.ce        = vif.alu_monitor_cb.ce;
			seq.mode      = vif.alu_monitor_cb.mode;
			seq.cin       = vif.alu_monitor_cb.cin;
			seq.cmd       = vif.alu_monitor_cb.cmd;
			seq.inp_valid = vif.alu_monitor_cb.inp_valid;
			seq.opa       = vif.alu_monitor_cb.opa;
			seq.opb       = vif.alu_monitor_cb.opb;
			seq.res       = vif.alu_monitor_cb.res;
			seq.err       = vif.alu_monitor_cb.err;
			seq.oflow     = vif.alu_monitor_cb.oflow;
			seq.cout      = vif.alu_monitor_cb.cout;
			seq.g         = vif.alu_monitor_cb.g;
			seq.l         = vif.alu_monitor_cb.l;
			seq.e         = vif.alu_monitor_cb.e;
			$display("Monitor @ %0t \n RST = %b | CE = %b | MODE = %b | CMD = %d | INP_VALID = %d | CIN = %b | OPA = %d | OPB = %d |",
				$time, vif.alu_monitor_cb.rst , vif.alu_monitor_cb.ce , vif.alu_monitor_cb.mode , vif.alu_monitor_cb.cmd , vif.alu_monitor_cb.inp_valid , 								  vif.alu_monitor_cb.cin , vif.alu_monitor_cb.opa , vif.alu_monitor_cb.opb );
			$display("Monitor @ %0t \n RES = %d | OFLOW = %b | COUT = %b | G = %b | L = %b | E = %b | ERR = %b |",
				$time, vif.alu_monitor_cb.res , vif.alu_monitor_cb.oflow , vif.alu_monitor_cb.cout , vif.alu_monitor_cb.g , vif.alu_monitor_cb.l , 									  	  vif.alu_monitor_cb.e , vif.alu_monitor_cb.err );
			mon_port.write(seq); 
		end
	endtask

endclass

`include "uvm_macros.svh"
package alu_pkg;
  import uvm_pkg::*;
	`include "defines.sv"
  `include "alu_sequence_item.sv"
  `include "alu_sequencer.sv"
  `include "alu_driver.sv"
  `include "alu_monitor.sv"
  `include "alu_agent.sv"
  `include "alu_coverage.sv"
  `include "alu_scoreboard.sv"
  `include "alu_environment.sv"
  `include "alu_sequence.sv"
  `include "alu_test.sv"
endpackage
`uvm_analysis_imp_decl(_mon_scb)
`uvm_analysis_imp_decl(_driv_scb)
   
class alu_scoreboard extends uvm_scoreboard;

  alu_sequence_item driver_queue[$];
  alu_sequence_item monitor_queue[$];
  
  logic [(RESULT_WIDTH - 1 ) + 6:0] monitor_results;
  logic [(RESULT_WIDTH - 1 ) + 6:0] reference_results;
  
  reg [RESULT_WIDTH - 1:0] t_mul;
   
  logic [RESULT_WIDTH -1:0] ref_res ;
  logic  ref_err , ref_oflow , ref_cout , ref_g , ref_l , ref_e;
  
  `uvm_component_utils(alu_scoreboard)
  uvm_analysis_imp_mon_scb#(alu_sequence_item, alu_scoreboard) mon_scb_port;
  uvm_analysis_imp_driv_scb#(alu_sequence_item, alu_scoreboard) driv_scb_port;

  function new(string name = "alu_scoreboard", uvm_component parent);
    super.new(name, parent);
  endfunction

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    driv_scb_port = new("driv_scb_port", this);
    mon_scb_port = new("mon_scb_port",this);
  endfunction
  
  function void write_mon_scb(alu_sequence_item packet_1);
    //$display("Scoreboard received monitor packet ");
    monitor_queue.push_back(packet_1);
  endfunction
  
  function void write_driv_scb(alu_sequence_item packet_2);
    //$display("Scoreboard received driver packet");
    driver_queue.push_back(packet_2);
  endfunction
  
  task run_phase(uvm_phase phase);
	 forever begin
       fork
         begin
           wait(monitor_queue.size() > 0);
           extract_outputs_from_monitor();
         end
       begin
         wait(driver_queue.size() > 0);
         extract_inputs_from_driver();
       end
       join
       comparision_report();
     end
    endtask
  
  task extract_outputs_from_monitor();
     alu_sequence_item packet_4;
     packet_4 = monitor_queue.pop_front();
    //  $display("scoreboard : monitor");
    //$display("scoreboard: Monitor @ %0t \n RES = %d | OFLOW = %b | COUT = %b | G = %b | L = %b | E = %b | ERR = %b |",$time, packet_4.res , packet_4.oflow ,      					packet_4.cout , packet_4.g , packet_4.l, packet_4.e , packet_4.err );
    monitor_results = { packet_4.res, packet_4.oflow, packet_4.cout, packet_4.g, packet_4.l, packet_4.e, packet_4.err };
    $display("time : %t | monitor_results_stored = %b", $time, monitor_results);
  endtask
 
  task extract_inputs_from_driver();
     alu_sequence_item packet_3;
      packet_3 = driver_queue.pop_front();
    //$display("scoreboard : driver");
    //$display("Scoreboard :Driver @ %0t \n RST = %b | CE = %b | MODE = %b | CMD = %d | INP_VALID = %d | CIN = %b | OPA = %d | OPB = %d ",$time, packet_3.rst, packet_3.ce, packet_3.mode, packet_3.cmd, packet_3.inp_valid, packet_3.cin, packet_3.opa, packet_3.opb);
    alu_reference_model(packet_3);
  endtask
  
  task alu_reference_model(input alu_sequence_item packet_3);
    if(packet_3.rst == 1 )begin
      ref_res ='b0 ;
      ref_oflow = 'b0; 
      ref_cout = 'b0;
      ref_g = 'b0 ; 
      ref_l = 'b0; 
      ref_e = 'b0; 
      ref_err = 'b0;
     end
    else if(packet_3.ce)begin
      ref_res ='b0 ;
      ref_oflow = 'b0; 
      ref_cout = 'b0;
      ref_g = 'b0 ; 
      ref_l = 'b0; 
      ref_e = 'b0; 
      ref_err = 'b0;
      t_mul = 'b0;
      if( packet_3.mode ) 
        arithematic_operation(packet_3);
      else
        logical_operation(packet_3);
    end
 
    
    $display("Scoreboard :reference input: @ %0t \n RST = %b | CE = %b | MODE = %b | CMD = %d | INP_VALID = %d | CIN = %b | OPA = %d | OPB = %d ",$time, packet_3.rst, packet_3.ce, packet_3.mode, packet_3.cmd, packet_3.inp_valid, packet_3.cin, packet_3.opa, packet_3.opb);
    reference_results = { ref_res, ref_oflow, ref_cout, ref_g, ref_l, ref_e, ref_err };
    $display(" time = %t | reference_results_stored = %b", $time, reference_results);
    
  endtask
  task arithematic_operation(input alu_sequence_item packet_3);
    case(packet_3.cmd)
     
      0:begin
        if( packet_3.inp_valid == 3) 
           begin
             ref_res = packet_3.opa + packet_3.opb;
             ref_cout = ( ref_res[`DATA_WIDTH] ) ? 1 : 0;
             $display( "ref_res = %0d | ref_cout = %0d ", ref_res, ref_cout);
           end
        else ref_err = 1;
        end
      
      1:begin
         if( packet_3.inp_valid == 3) 
           begin
             ref_res = ( packet_3.opa - packet_3.opb ) & ( { { (`DATA_WIDTH - 1){1'b0} } , { (`DATA_WIDTH+1){1'b1} } } );
             ref_oflow = ( ( packet_3.opa < packet_3.opb ) || ( ( packet_3.opa == packet_3.opb ) && ( packet_3.cin == 1 ) ) ) ? 1 :0;
           end
        else ref_err = 1;
        end
      
      2:begin
        if( packet_3.inp_valid == 3) 
           begin
             ref_res = packet_3.opa + packet_3.opb + packet_3.cin;
             ref_cout = ( ref_res[`DATA_WIDTH] ) ? 1 : 0;
             $display( "ref_res = %0d | ref_cout = %0d ", ref_res, ref_cout);
           end
        else ref_err = 1;
        end
      
      3:begin
        if( packet_3.inp_valid == 3) 
           begin
             ref_res = ( packet_3.opa - packet_3.opb - packet_3.cin ) & ( { { (`DATA_WIDTH - 1){1'b0} } , { (`DATA_WIDTH+1){1'b1} } } );
             ref_oflow = ( ( packet_3.opa < packet_3.opb ) || ( ( packet_3.opa == packet_3.opb ) && ( packet_3.cin == 1 ) ) ) ? 1 :0;
           end
        else ref_err = 1;
        end
      
      4:begin
        if( packet_3.inp_valid == 1)
          begin
		    ref_res = packet_3.opa + 1;
            ref_cout = ( ref_res[`DATA_WIDTH] ) ? 1 : 0;
          end
        else ref_err = 1;
        end
      
      5:begin
        if( packet_3.inp_valid == 1)
          begin
            ref_res = ( packet_3.opa - 1 ) & ( { { (`DATA_WIDTH-1){1'b0} } , { (`DATA_WIDTH + 1){1'b1} } } );
            ref_oflow = ( packet_3.opa == 0 ) ? 1 : 0;
          end
        else ref_err = 1;
        end
      
      6:begin
        if( packet_3.inp_valid == 2)
          begin
		    ref_res = packet_3.opb + 1;
            ref_cout = ( ref_res[`DATA_WIDTH] ) ? 1 : 0;
          end
        else ref_err = 1;
        end
      
      7:begin
        if( packet_3.inp_valid == 2)
          begin
            ref_res = ( packet_3.opb - 1 ) & ( { { (`DATA_WIDTH-1){1'b0} } , { (`DATA_WIDTH+1){1'b1} } } );
            ref_oflow = ( packet_3.opb == 0 ) ? 1 : 0;
          end
        else ref_err = 1;
        end
      
      8:begin
        if( packet_3.inp_valid == 3 )
          begin
            
            ref_res = 0;
            
            if (packet_3.opa == packet_3.opb )
            begin
              ref_e = 'b1;
              ref_g = 'b0;
              ref_l = 'b0;
            end
            
            else if( packet_3.opa > packet_3.opb )
            begin
              ref_e = 'b0;
              ref_g = 'b1;
              ref_l = 'b0;
            end		          
            
            else 
            begin
              ref_e = 'b0;
              ref_g = 'b0;
              ref_l = 'b1;
            end
          
          end
        else ref_err = 1;
        end
     
      9:begin
        if(packet_3.inp_valid == 3) begin
           t_mul  = ( packet_3.opa + 1 ) * ( packet_3.opb + 1 );  
           ref_res =  t_mul;
           $display( "ref_res = %0d ", ref_res);
         end
        else ref_err = 1;
        end
      
      10:begin
         if(packet_3.inp_valid == 3) begin
           bit [`DATA_WIDTH - 1:0] temp = ( packet_3.opa << 1 ); 
           t_mul  = ( temp ) * ( packet_3.opb );
		   ref_res =  t_mul;
         end
         else ref_err = 1;
         end
      default:begin
               ref_err = 1;
              end
     endcase    
    
  endtask
  
  task logical_operation(input alu_sequence_item packet_3);
    case(packet_3.cmd)
      
      0: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( packet_3.opa & packet_3.opb ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
         
      1: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( ~( packet_3.opa & packet_3.opb ) ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
                 
      2: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( packet_3.opa | packet_3.opb ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
         
      3: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( ~( packet_3.opa | packet_3.opb ) ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
         
      4: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( packet_3.opa ^ packet_3.opb ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
         
      5: begin
         if(packet_3.inp_valid == 3) begin
           ref_res = ( ~( packet_3.opa ^ packet_3.opb ) ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } ); 
	     end
         else ref_err = 1;
         end
         
      6: begin
         if(packet_3.inp_valid == 1) begin
           ref_res = ( ~( packet_3.opa ) ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	     end
         else ref_err = 1;
         end
         
      7: begin
         if(packet_3.inp_valid == 2) begin
           ref_res = ( ~( packet_3.opb ) ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	     end
         else ref_err = 1;
         end
         
      8: begin
         if(packet_3.inp_valid == 1) begin
           ref_res = ( ( packet_3.opa ) >> 1 ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	     end
         else ref_err = 1;
         end
         
      9: begin
         if(packet_3.inp_valid == 1) begin
           ref_res = ( ( packet_3.opa ) << 1 ) & ( { {`DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	     end
         else ref_err = 1;
         end
         
      10: begin
          if(packet_3.inp_valid == 2) begin
            ref_res = ( ( packet_3.opb ) >> 1 ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	      end
          else ref_err = 1;
          end
         
      11: begin
          if(packet_3.inp_valid == 2) begin
            ref_res = ( ( packet_3.opb ) << 1 ) & ( { { `DATA_WIDTH{1'b0} } , { `DATA_WIDTH{1'b1} } } );
	      end
          else ref_err = 1;
          end
         
      12: begin
          if(packet_3.inp_valid == 3) begin
            ref_res[ `DATA_WIDTH - 1 : 0 ] = 
            ( packet_3.opa << packet_3.opb[($clog2(`DATA_WIDTH) - 1):0] ) | ( packet_3.opa >> ( `DATA_WIDTH - packet_3.opb[($clog2(`DATA_WIDTH) - 1):0]) );
            if(|(packet_3.opb[ `DATA_WIDTH - 1 : ($clog2(`DATA_WIDTH) + 1)]))      
               ref_err = 1; 
            else          
               ref_err = 0;
          end
          else ref_err = 1;
          end
         
      13: begin
          if(packet_3.inp_valid == 3) begin
            ref_res[ `DATA_WIDTH - 1 : 0 ] = 
            ( packet_3.opa >> packet_3.opb[($clog2(`DATA_WIDTH) - 1):0] ) | ( packet_3.opa << ( `DATA_WIDTH - packet_3.opb[($clog2(`DATA_WIDTH) - 1):0]) );
            if(|(packet_3.opb[ `DATA_WIDTH - 1 : ($clog2(`DATA_WIDTH) + 1)]))      
               ref_err = 1; 
            else          
               ref_err = 0;
          end
          else ref_err = 1;
          end
           
      default : begin
                  ref_err = 1;
                end
    endcase
    
  endtask
  
  task comparision_report();
    if( monitor_results === reference_results )
      $display("<-----------------------------PASS----------------------------->" );
    else
      $display("<-----------------------------FAIL----------------------------->" );
  endtask
  
endclass
class alu_sequence_item extends uvm_sequence_item;
	rand logic rst;
	rand logic ce, mode , cin;
	rand logic [`DATA_WIDTH - 1:0] opa , opb;
	rand logic [`CMD_WIDTH - 1:0] cmd;
	rand logic [1:0] inp_valid;
       logic [RESULT_WIDTH - 1 :0] res ;
	     logic  err , oflow , cout , g , l , e;

	`uvm_object_utils_begin(alu_sequence_item)

	`uvm_field_int(rst,UVM_ALL_ON)
	`uvm_field_int(ce,UVM_ALL_ON)
	`uvm_field_int(mode,UVM_ALL_ON)
	`uvm_field_int(cin,UVM_ALL_ON)
	`uvm_field_int(cmd,UVM_ALL_ON)
	`uvm_field_int(inp_valid,UVM_ALL_ON)
	`uvm_field_int(opa,UVM_ALL_ON)
	`uvm_field_int(opb,UVM_ALL_ON)
	`uvm_field_int(res,UVM_ALL_ON)
	`uvm_field_int(err,UVM_ALL_ON)
	`uvm_field_int(oflow,UVM_ALL_ON)
	`uvm_field_int(cout,UVM_ALL_ON)
	`uvm_field_int(g,UVM_ALL_ON)
	`uvm_field_int(l,UVM_ALL_ON)
	`uvm_field_int(e,UVM_ALL_ON)

	`uvm_object_utils_end

	function new(string name = "alu_sequence_item");
		super.new(name);
	endfunction

endclass
class alu_sequencer extends uvm_sequencer#(alu_sequence_item);
  `uvm_component_utils(alu_sequencer)
  function new(string name, uvm_component parent);
    super.new(name,parent);
  endfunction
endclass


class alu_sequence extends uvm_sequence#(alu_sequence_item);

	`uvm_object_utils(alu_sequence)
	function new(string name = "alu_sequence");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items)begin
			req = alu_sequence_item::type_id::create("req");
			wait_for_grant();
			void'(req.randomize());
			send_request(req);
			wait_for_item_done();
			$display("unblocked");
		end
	endtask
endclass

class rst_ce extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(rst_ce)

	function new(string name = "rst_ce");
		super.new(name);
	endfunction

	task body();
//		repeat(`no_of_items) begin
		  `uvm_do_with(req,{req.mode == 1;req.rst == 1;req.ce == 0;req.cmd== 0;req.inp_valid == 3;})
			`uvm_do_with(req,{req.mode == 1;req.rst == 0;req.ce == 0;req.cmd== 0;req.inp_valid == 3;})
		  `uvm_do_with(req,{req.mode == 1;req.rst == 1;req.ce == 1;req.cmd== 0;req.inp_valid == 3;})
//		end
	endtask
endclass 

class single_operand_arithmatic extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(single_operand_arithmatic)

	function new(string name = "single_operand_arithmatic");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 1;
					req.inp_valid inside {[1:2]};
					req.cmd inside {[4:7]};
				}
			)
		end
	endtask
endclass 

class single_operand_logical extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(single_operand_logical)

	function new(string name = "single_operand_logical");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid inside {[1:2]};
					req.cmd inside {[6:11]};
				}
			)
		end
	endtask
endclass 

class two_operand_arithmatic extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(two_operand_arithmatic)

	function new(string name = "two_operand_arithmatic");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 1;
					req.inp_valid == 3;
					req.cmd inside {[0:3],[8:10]};
				}
			)
		end
	endtask
endclass 

class two_operand_logical extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(two_operand_logical)

	function new(string name = "two_operand_logical");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid == 3;
					req.cmd inside {[0:5],[12:13]};
				}
			)
		end
	endtask
endclass 

class single_operand_arithmatic_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(single_operand_arithmatic_error)

	function new(string name = "single_operand_arithmatic_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 1;
					req.inp_valid inside { 0 , 3 };
					req.cmd inside {[4:7]};
				}
			)
		end
	endtask
endclass 

class single_operand_logical_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(single_operand_logical_error)

	function new(string name = "single_operand_logical_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid inside { 0 , 3 };
					req.cmd inside {[6:11]};
				}
			)
		end
	endtask
endclass 

class two_operand_arithmatic_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(two_operand_arithmatic_error)

	function new(string name = "two_operand_arithmatic_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 1;
					req.inp_valid == 0;
					req.cmd inside {[0:3],[8:10]};
				}
			)
		end
	endtask
endclass 

class two_operand_logical_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(two_operand_logical_error)

	function new(string name = "two_operand_logical_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid == 0;
					req.cmd inside {[0:5],[12:13]};
				}
			)
		end
	endtask
endclass 

class rotate_right_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(rotate_right_error)

	function new(string name = "rotate_right_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid == 3;
					req.cmd == 13;
					req.opa == 1 ;
					req.opb inside {[8:255]};
				}
			)
		end
	endtask
endclass 

class rotate_left_error extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(rotate_left_error)

	function new(string name = "rotate_left_error");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid == 3;
					req.cmd == 12;
					req.opa == 1 ;
					req.opb inside {[8:255]};
				}
			)
		end
	endtask
endclass 

class cycle_16_arithmatic extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(cycle_16_arithmatic)

	function new(string name = "cycle_16_arithmatic");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 1;
					req.inp_valid inside {[1:2]};
					req.cmd inside {[0:3],[8:10]};
				}
			)
		end
	endtask
endclass 

class cycle_16_logical extends uvm_sequence#(alu_sequence_item);
	`uvm_object_utils(cycle_16_logical)

	function new(string name = "cycle_16_logical");
		super.new(name);
	endfunction

	task body();
		repeat(`no_of_items) begin
			`uvm_do_with( 
				req,
				{ 
					req.rst == 0;
					req.ce == 1;
					req.mode == 0;
					req.inp_valid inside {[1:2]};
					req.cmd inside {[0:5],[12:13]};
				}
			)
		end
	endtask
endclass 

class alu_regression extends uvm_sequence#(alu_sequence_item);

	`uvm_object_utils(alu_regression)
	rst_ce seq0;

	single_operand_arithmatic seq1;
	single_operand_logical    seq2;
	two_operand_arithmatic    seq3;
	two_operand_logical       seq4;

	single_operand_arithmatic_error seq5;
	single_operand_logical_error    seq6;
	two_operand_arithmatic_error    seq7;
	two_operand_logical_error       seq8;

	rotate_right_error  seq9;
	rotate_left_error   seq10;

	cycle_16_arithmatic seq11;
	cycle_16_logical    seq12;

	function new(string name = "alu_regression");
		super.new(name);
	endfunction

	task body();
		`uvm_do(seq0)
		`uvm_do(seq1)
		`uvm_do(seq2)
		`uvm_do(seq3)         
		`uvm_do(seq4)
		`uvm_do(seq5)
		`uvm_do(seq6)
		`uvm_do(seq7)         
		`uvm_do(seq8) 
		`uvm_do(seq9)         
		`uvm_do(seq10)
		`uvm_do(seq11)         
		`uvm_do(seq12) 
  endtask
endclass
class alu_test extends uvm_test;

	`uvm_component_utils( alu_test)
	alu_environment alu_env;
	alu_sequence seq;

	function new(string name = "alu_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		alu_env = alu_environment::type_id::create("alu_environment", this);
		seq = alu_sequence::type_id::create("alu_seq");
	endfunction : build_phase

	function void end_of_elaboration();
		uvm_top.print_topology();
	endfunction

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class rst_ce_test extends alu_test;

	`uvm_component_utils( rst_ce_test)
	rst_ce seq0;

	function new(string name = " rst_ce_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq0 = rst_ce ::type_id::create("alu_seq0");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq0.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass


class single_operand_arithmatic_test extends alu_test;

	`uvm_component_utils( single_operand_arithmatic_test)
	single_operand_arithmatic seq1;

	function new(string name = " single_operand_arithmatic_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq1 = single_operand_arithmatic ::type_id::create("alu_seq1");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq1.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class single_operand_logical_test extends alu_test;

	`uvm_component_utils( single_operand_logical_test)
	single_operand_logical seq2;

	function new(string name = " single_operand_logical_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq2 = single_operand_logical::type_id::create("alu_seq2");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq2.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class two_operand_arithmatic_test extends alu_test;

	`uvm_component_utils( two_operand_arithmatic_test)
	two_operand_arithmatic seq3;

	function new(string name = " two_operand_arithmatic_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq3 = two_operand_arithmatic ::type_id::create("alu_seq3");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq3.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class two_operand_logical_test extends alu_test;

	`uvm_component_utils( two_operand_logical_test)
	two_operand_logical seq4;

	function new(string name = " two_operand_logical_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq4 = two_operand_logical::type_id::create("alu_seq4");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq4.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class single_operand_arithmatic_error_test extends alu_test;
	`uvm_component_utils( single_operand_arithmatic_error_test)
	single_operand_arithmatic_error seq5;
	function new(string name = " single_operand_arithmatic_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq5 = single_operand_arithmatic_error ::type_id::create("alu_seq5");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq5.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class single_operand_logical_error_test extends alu_test;

	`uvm_component_utils( single_operand_logical_error_test)
	single_operand_logical_error seq6;

	function new(string name = " single_operand_logical_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq6 = single_operand_logical_error::type_id::create("alu_seq6");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq6.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class two_operand_arithmatic_error_test extends alu_test;

	`uvm_component_utils( two_operand_arithmatic_error_test)
	two_operand_arithmatic_error seq7;

	function new(string name = " two_operand_arithmatic_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq7 = two_operand_arithmatic_error ::type_id::create("alu_seq7");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq7.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class two_operand_logical_error_test extends alu_test;

	`uvm_component_utils( two_operand_logical_error_test)
	two_operand_logical_error seq8;

	function new(string name = " two_operand_logical_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq8 = two_operand_logical_error::type_id::create("alu_seq8");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq8.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class rotate_right_error_test extends alu_test;

	`uvm_component_utils( rotate_right_error_test)
	rotate_right_error seq9;

	function new(string name = "rotate_right_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq9 = rotate_right_error::type_id::create("alu_seq9");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq9.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class rotate_left_error_test extends alu_test;

	`uvm_component_utils( rotate_left_error_test)
	rotate_left_error seq10;

	function new(string name = "rotate_left_error_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq10 = rotate_left_error::type_id::create("alu_seq10");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq10.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);  
	endtask
endclass

class cycle_16_arithmatic_test extends alu_test;

	`uvm_component_utils( cycle_16_arithmatic_test)
	cycle_16_arithmatic seq11;

	function new(string name = "cycle_16_arithmatic_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq11 = cycle_16_arithmatic::type_id::create("alu_seq9");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq11.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass

class cycle_16_logical_test extends alu_test;

	`uvm_component_utils( cycle_16_logical_test)
	cycle_16_logical seq12;

	function new(string name = "cycle_16_logical_test", uvm_component parent);
		super.new(name,parent);
	endfunction : new

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		seq12 = cycle_16_logical::type_id::create("alu_seq10");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		seq12.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass


class alu_regression_test extends alu_test;

	`uvm_component_utils(alu_regression_test)
	alu_regression reg_test;

	function new(string name = "alu_regression_test", uvm_component parent);
		super.new(name,parent);
	endfunction

	function void build_phase(uvm_phase phase);
		super.build_phase(phase);
		reg_test = alu_regression::type_id::create("reg_test");
	endfunction : build_phase

	task run_phase(uvm_phase phase);
		phase.raise_objection(this);
		reg_test.start(alu_env.alu_agt.alu_seqr);
		phase.drop_objection(this);
	endtask
endclass


`include "defines.sv"
`include "alu_design.sv"
`include "alu_interface.sv"
`include "alu_package.sv"
`include "alu_assertions.sv"
import uvm_pkg::*;
import alu_pkg::*;
module top;
	bit clk = 0;
//	bit rst;

	always #5 clk = ~clk;

/*	initial begin
		rst = 1;
		repeat(3)@(posedge clk);
		rst = 0;
	  end
*/
	
	alu_interface vif(clk);

	alu_design DUT(
		.CLK(vif.clk),
		.RST(vif.rst),
		.CE(vif.ce),
		.MODE(vif.mode),
		.CIN(vif.cin),
		.INP_VALID(vif.inp_valid),
		.CMD(vif.cmd),
		.OPA(vif.opa),
		.OPB(vif.opb),
		.RES(vif.res),
		.ERR(vif.err),
		.OFLOW(vif.oflow),
		.COUT(vif.cout),
		.G(vif.g),
		.L(vif.l),
		.E(vif.e)
	);

 bind vif alu_assertions ASSERT(
     .clk(vif.clk),
	   .rst(vif.rst),
	   .ce(vif.ce),
	   .mode(vif.mode),
	   .cin(vif.cin),
	   .inp_valid(vif.inp_valid),
	   .cmd(vif.cmd),
	   .opa(vif.opa),
	   .opb(vif.opb),
	   .res(vif.res),
	   .err(vif.err),
	   .oflow(vif.oflow),
	   .cout(vif.cout),
	   .g(vif.g),
	   .l(vif.l),
	   .e(vif.e)
 );

	initial begin 
		uvm_config_db#(virtual alu_interface)::set(null,"*","vif",vif);
		$dumpfile("dump.vcd");
		$dumpvars;
	end

	initial begin 
		run_test("alu_regression_test");
		#1000 $finish;
	end
endmodule
`define DATA_WIDTH 8
`define CMD_WIDTH  4  
`define no_of_items 2 
`define DW 8
`define CW 4
parameter RESULT_WIDTH = 2 * `DATA_WIDTH ;
